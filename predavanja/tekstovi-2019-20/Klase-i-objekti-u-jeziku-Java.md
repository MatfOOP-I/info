# Објектно орјентисано

# програмирање

## Владимир Филиповић

## vladaf@matf.bg.ac.rs

## Александар Картељ

## kartelj@matf.bg.ac.rs


# Класе и објекти у

# програмском језику Јава

## Владимир Филиповић

## vladaf@matf.bg.ac.rs

## Александар Картељ

## kartelj@matf.bg.ac.rs


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 3 / 64

- Цео Јава код се налази унутар класа.
- Једној класи одговара једна датотека са екстензијом .java.

###### Назив класе и назив датотеке треба да буду исти.

- Класа се дефинише коришћењем кључне речи class.
- На пример, наредбом:

###### class Duzina је дефинисана нова класа са називом Duzina,

###### а блок (тј. кôд између витичастих заграда), који следи,

###### описује каква је структура новонаправљене класе.

### Дефиниција класе у Јави


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 4 / 64

- Синтаксни дијаграм за декларисање класа има следећи облик:
- Модификатор је резервисана реч која мења основно значење

###### неке конструкције у Јави:

**<** modifikator **>::=** public **|** private **|** protected **|** abstract **|** final **|** static
**|** native **|** strictfp **|** synchronized **|** transient **|** volatile

### Дефиниција класе у Јави (2)


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 5 / 64

- Металингвистичка променљива pridruživanje

###### oдређује из које класе је дата класа изведена,

###### односно, да ли дата класа имплементира неке интерфејсе:

- Металингвистичка променљива ime може бити

###### индентификатор или идентикатори раздвојени тачком,

###### док је lista imena низ имена раздвојених зарезима:

### Дефиниција класе у Јави (3)


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 6 / 64

######  Тело класе представља блок у којем се наводе разне

###### декларације:

### Дефиниција класе у Јави (4)


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 7 / 64

###### Постоји неколико врста променљивих :

###### 1. поља - променљиве декларисане у самој класи

- представљају чланове-податке унутар класе, тј. описују

###### атрибуте објекта који је примерак дате класе;

###### 2. локалне променљиве - променљиве декларисане у телу метода

###### или блоку;

###### 3. формални аргументи - променљиве декларисане у заглављу

###### метода.

- У даљем разматрању се концентришемо на променљиве

###### чланове, тј. поља.

### Класе у Јави – поља


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 8 / 64

######  Декларација поља се састоји од три компоненте:

1. модификатора (који се опционо појављују),
2. типа поља (тип)
3. и имена поља (идентификатор).

######  Модификатори омогућују:

 да се подеси видљивост дате променљиве члана (тј. поља),

```
 да се одреди да ли се ради о променљивој примерка
(инстанцној променљивој) или о класној (статичкој) променљивој,
```
```
 као и да ли вредност променљиве постаје непроменљива
непосредно по креирању (финална тј. константна).
```
######  У том смислу, разликују се:

 променљива примерка,

 класна променљива

 и константа.

### Класе у Јави – поља (2)


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 9 / 64

###### Променљиве примерка

- Сваки од креираних објеката дате класе садржи сопствени

###### примерак те променљиве.

- Променљивој примерка се може приступити само ако се

###### референцира примерак класе који садржи ту променљиву.

- Промена вредности једне променљиве примерка нема утицаја

###### на остале.

###### Пример.

###### class Point extends GeometryObject {

int x **;** int y **;**
.................. **..
}**

### Класе у Јави – поља (3)


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 10 / 64

######  Као што је раније истакнуто, компонентама објекта

###### приступа се преко тзв. тачка-нотације

######  То се односи и на инстанцне променљиве и на инстанцне методе

###### Пример.

###### prviObjekt. prom ;

prviObjekt**.** prom**.** stanje **;**

prviObjekat**.** prom**.** stanje **= true;**

###### Пример.

###### tackaA. x = 23 ;

int xKoord **=** tackaA**.** x **;**

tackaA**.** y **=** 94 **;**

System**.** out**.** println **(** tackaA**.** x **+** “ **,** ” **+** tackaA**.** y **);**

### Класе у Јави – поља (4)


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 11 / 64

###### Класне променљиве

- Класа садржи само једну копију класне променљиве

###### и та променљива је дељена међу свим објектима дате класе.

- Она постоји чак иако се не креира ниједан примерак дате класе.
- Она припада класи и њу могу сви да референцирају,

###### а не само примерци дате класе.

- Класна променљива се декларише коришћењем модификатора

###### static.

### Класе у Јави – поља (5)


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 12 / 64
class ClanPorodice **{**
static String prezime **=** “Jankovic” **;** // klasna promenljiva
int uzrast **;** // instancna promenljiva.
String ime **;** // instancna promenljiva
.....................
ClanPorodice otac **= new** ClanPorodice **(** “Nikola” **,** 52 **);**
ClanPorodice sin **= new** ClanPorodice **(** “Petar” **,** 21 **);**
.....................
**}**
ClanPorodice
prezime
sin
otac

###### uzrast ime

(^21) Petar
52 Nikola

### Класе у Јави – поља (6)

###### Jankovic


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 13 / 64

######  За приступ класној променљивој се користи тачка-нотација,

###### при чему се као прималац поруке може користити:

###### име класе или име неке инстанце класе.

######  Препоручује се коришћење имена класе.

###### Пример.

class ClanPorodice **{**

static String prezime **=** “Jankovic” **;**

String ime **;**

int godine **;**

...............

**}**

###### и креиран примерак sin:

ClanPorodice sin **= new** ClanPorodice **();**

###### Класној променљивој prezime можемо приступити на следеће начине:

System**.** out**.** println **(** “Porodicno prezime je **:** “ **+** sin**.** prezime **);**
System**.** out**.** println **(** “Porodicno prezime je **:** “ **+** ClanPorodice**.** prezime **);**

### Класе у Јави – поља ( 7 )


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 14 / 64

###### Константе (финалне променљиве)

- Модификатор final дефинише да када једном променљива добије

###### вредност није допуштена даља промена њене вредности.

- Може се примењивати и код класних и код инстанцних

###### променљивих као и код локалних променљивих.

###### Пример.

final float STOPA **=** 2.3f **;**

final boolean NETACNO **= false;**

final int BROJ_STRANA **=** 200 **;**

### Класе у Јави – поља ( 8 )


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 15 / 64

- У оквиру метода примерка или конструктора,

###### променљива this представља референцу на сам тај објекат.

- Коришћењем this се може реферисати на ма које поље текућег

###### објекта над којим се позива метод примерка или конструктор.

###### Пример.

```
{
this. x = 0 ;
this. y = 0 ;
}
```
###### У претходном примеру се кључна реч this може изоставити.

### Класе у Јави – this


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 16 / 64

- Најчешћи разлог за коришћење ове променљиве је то што

###### поље класе буде сакривено параметром метода или параметром

###### конструктора.

###### Пример.

public void pomeri **(** int x **,** int y **) {
this.** x **=** x **;
this.** y **=** y **;
}**

- Овде је кључна реч this неопходна да подвуче разлику између

###### инстанцних променљивих и параметара метода.

- Сваки од аргумента метода сакрива по једно поље објекта, тако

###### да је унутар метода x ознака локалне копије првог аргумента.

- Да би се реферисало на поље x примерка класе Point, унутар

###### метода се мора користити this.x.

### Класе у Јави – this (2)


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 17 / 64

###### Примери:

###### У наредбама које следе се користи кључна реч this:

t **= this.** a **;** // a -instancna promenljiva tekućeg objekta
**this.** prviMetod **(this);** // poziva se metod
**return this;** //vraća se tekući objekt iz metoda

###### У неким од наведених случајева може се изоставити:

###### t = a ; prviMetod (this);

###### У некима не може:

###### return this;

### Класе у Јави – this (3)


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 18 / 64

######  Опсег важења променљиве је део програма у којем име

###### променљиве може да се користи.

######  Код локалних променљивих, опсег важења променљиве је блок у

###### којем је дефинисана од места где је дефинисана.

###### Пример.

**{**

int a **=** 1 **;** //ovde se može pozivati a, ali ne i b!

**{** //ovde se može pozivati a, ali ne jos b!

int b **=** 2 **;** // ovde se mogu pozivati a i b!

**}** // ovde se može pozivati a, ali ne i b!

**}**

// ovde se ne mogu koristiti niti a, niti b!

### Опсег важења променљиве


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 19 / 64

######  Класним променљивима се може приступати у сваком тренутку

###### рада програма.

######  Променљивима примерка се може приступати сво време док

###### постоји објекат – примерак дате класе.

###### Пример.

class Opseg **{**

int n **,** probna **=** 10 **;**

void stampaProbnu **() {**

int probna **=** 30 **;**

System**.** out**.** println **(** “Lokalna probna **=** “ **+** probna **);**

**}**

n **=** probna **;**

**}**

######  Ако треба да се унутар метода приступи сакривеном пољу probna,

###### то се постиже помоћу this.probna.

### Опсег важења променљиве (2)


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 20 / 64

######  Методи се појављују у телу класе.

######  Они садрже декларације локалних променљивих

###### и друге Јава наредбе које се извршавају при позиву метода.

######  Аргументи метода се наводе у заградама иза имена метода

###### (број аргумената може бити нула).

######  Приликом декларације метода у класи, наводи се тип аргумената.

######  При позиву метода наводе се стварни аргументи.

### Класе у Јави - методи


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 21 / 64

- Метод је самостални блок кода који има име

###### и својство вишеструке употребљивости.

- Параметри омогућавају да се унесу вредности у метод:
- Металингвистичка променљива blok је дефинисана у једној од

###### претходних презентација.

###### ( )

### Класе у Јави – методи (2)


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 22 / 64

- Метод може вратити вредност

###### и онда је потребно навести тип повратне врености.

- Уколико метод не враћа вредност, његов тип је void.
- Повратна вредност из метода се враћа преко return наредбе:
- Синтакса израза је дефинисана на слајдовима претходне

###### презентације.

### Класе у Јави – методи (3)


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 23 / 64

- Методи могу бити:

###### 1. инстанцни (метод примерка)

###### 2. и класни (статички).

- Класни методи се не односе на инстанцне променљиве, тј. не

###### мора постојати ни једна инстанца, а метод се може користити!

- У телу класног метода се не може реферисати на променљиве

###### примерка дате класе, већ само на класне променљиве за дату класу.

- Метод main(String args[]), који је неопходан у апликацијама, је увек

###### класни, јер пре његовог стартовања не постоји ни једна инстанца.

- Не прави се копија класног метода за сваку инстанцу,

###### већ се он једанпут дефинише.

### Класе у Јави – методи (4)


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 24 / 64

######  Методи омогућавају да се дугачак код разбије у мање целине

###### и на тај начин доприносе прегледности кода.

######  Основна структура метода:

######  Да би метод вратио вредност, мора имати бар једну наредбу

return.

Telo

metoda

{

// Kod metoda

}

povratni- tip imeMetoda(arg1, arg2,...,argn)

### Класе у Јави – методи ( 5 )


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 25 / 64

######  Име метода заједно са типом и редоследом параметара

###### чини потпис метода.

######  Потпис два метода у класи мора бити различит,

###### како би компајлер могао да одреди који метод се позива.

```
povratni - tip imeMetoda ( arg1 , arg2 , ... , argn ) {
// Kod metoda
}
```
######  Приликом позива метода, на место формалних аргумената

###### (параметара), наводе се стварни аргументи.

######  Код навођења формалних аргумената, за сваки аргумент мора се

###### навести тип аргумента.

```
Potpis metoda
```
### Класе у Јави – методи ( 6 )


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 26 / 64

###### У наредбама у телу метода се могу користити четири

###### потенцијална извора података:

###### 1. формални аргументи метода,

###### 2. инстанцне и класне променљиве,

###### 3. локалне променљиве, дефинисане у телу метода и

###### 4. вредности које враћу други методи који су позвани у

###### текућем.

### Класе у Јави – методи ( 7 )


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 27 / 64

######  Дефинисање метода са истим именом, али различитим

###### параметрима назива се преоптерећење метода.

###### Пример.

class Pravougaonik **{**

int x1 **=** 0 **;**

int x2 **=** 0

int y1 **=** 0 **;**

int y2 **=** 0 **;**

Pravougaonik gradi **(** int x1 **,** int y1 **,** int x2 **,** int y2 **) {**

**this.** x1 **=** x1 **;**

**this.** y1 **=** y1 **;**

**this.** x2 **=** x2 **;**

**this.** y2 **=** y2 **;**

**return this;**

**}**

**}**

### Преоптерећење метода


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 28 / 64
Pravougaonik gradi **(** Point goreLevo **,** Point doleDesno **) {**
x1 **=** goreLevo**.** x **;**
y1 **=** goreLevo**.** y **;**
x2 **=** doleDesno**.** x **;**
y2 **=** doleDesno**.** y **;
return this;
}**
Pravougaonik gradi **(** Point goreLevo **,** int l **,** int h **){**
x1 **=** goreLevo**.** x **;**
y1 **=** goreLevo**.** y **;**
x2 **=** goreLevo**.** x **+** l **;**
y2 **=** goreLevo**.** y **+** h **;
return this;
}**
void printPrav **(){**
System**.** out**.** println **(** “Pravougaonik **:[** “ **(+** x1 **+** ” **,** ” **+** y1 **+** ” **)** , **(** ” **+** x2 **+** ” **,** ” **+** y2 **+** ” **)]** ” **);
}**

### Преоптерећење метода (2)


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 29 / 64
public static void main **(** String args **[]){**
Pravougaonik p **= new** Pravougaonik **();**
p**.** gradi **(** 10 **,** 20 **,** 30 **,** 40 **);**
p**.** printPrav **();**
p**.** gradi **(new** Point **(** 10 **,** 10 **), new** Point **(** 30 **,** 30 **));**
p**.** printPrav **();**
p**.** gradi **(new** Point **(** 10 **,** 10 **),** 20 **,** 30 **);**
p**.** printPrav **();
}**

### Преоптерећење метода (3)


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 30 / 64

- Приликом креирања конкретног примерка неке класе (преко

###### оператора new), увек се позива конструктор те класе.

- Конструктор је метод класе који се позива приликом креирања

###### новог примерка дате класе.

- Карактеристике конструктора:
    - никад не враћа вредност
    - његово име се поклапа са именом класе.
- Као и код осталих типова метода, типови и бројеви формалних

###### параметара при декларацији и позиву се морају поклапати.

### Конструктор


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 31 / 64

######  Уколико програмер није дефинисао конструктор за дату класу,

###### преводилац позива подразумевани конструктор.

######  Подразумевани конструктор:

 нема аргумената;

```
 иницијализује све инстанцне и класне променљиве
на подразумеване вредности.
```
######  Ако је програмер дефинисао бар један конструктор за дату класу,

###### онда подразумевани конструктор више не постоји.

### Конструктор (2)


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 32 / 64
class Knjiga **{**
String autor **;**
String naslov **;**
int brojStrana **;**
Knjiga **(** String a **,** String n **,** int bs **) {**
autor **=** a **;**
naslov **=** n **;**
brojStrana **=** bs **;
}**
void stampaPod **() {**
System**.** out**.** println **(** “Autor **:** ” **+** autor **);**
System**.** out**.** println **(** “Naslov **:** ” **+** naslov **);**
System**.** out**.** println **(** “Bro strana **:** ” **+** brojStrana **);
}**
public static void main **(** String args **[]) {**
Knjiga jedina **;**
jedina **= new** Knjiga **(** ”Ivo Andric” **,** “Gospodjica” **,** 257 **);**
jedina**.** stampPod **();
}
}**

### Конструктор ( 3 )


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 33 / 64

- Конструктори могу бити преоптерећени,

###### исто као и остали методи.

- Ако постоји додатни конструктор, који има неке нове особине,

###### у њему се може позвати већ постојећи конструктор употребом

###### кључне речи this на следећи начин:

```
this( arg1 , arg2 , ... );
```
### Преоптерећење конструктора


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 34 / 64
class Knjiga2 **{**
String autor **;**
String naslov **;**
int brojStrana **;**
Knjiga2 **(** String a **,** String n **,** int bs **) {**
autor **=** a **;**
naslov **=** n **;**
brojStrana **=** bs **;
}**
Knjiga2 **(** String a **,** String n **) {
this(** a **,** n **,** 200 **);
}**
Knjiga2 **(** String a **) {
this(** a **,** “Gorski vijenac” **,** 140 **);
}**
Knjiga2 **() {
this(** “Njegos” **,** “Gorski vijenac” **,** 140 **);
}
}**

### Преоптерећење конструктора (2)


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 35 / 64
void stampaPod **() {**
System**.** out**.** println **(** “Autor **:** ” **+** autor **);**
System**.** out**.** println **(** “Naslov **:** ” **+** naslov **);**
System**.** out**.** println **(** “Bro strana **:** ” **+** brojStrana **);
}**
public static void main **(** String args **[]) {**
Knjiga2 prva **;**
prva **= new** Knjiga2 **(** ”Ivo Andric” **,** “Gospodjica” **,** 257 **);**
prva**.** stampPod **();**
Knjiga2 druga **= new** Knjiga2 **();**
druga**.** stampPod **();**
prva **= new** Knjiga2 **(** “Dzordz Orvel” **);**
prva**.** stampPod **();**
druga **= new** Knjiga2 **(** “Borislav Pekic” **,** “Atlantida” **);**
druga**.** stampPod **();
}**

### Преоптерећење конструктора (3)


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 36 / 64

######  Објекат чије унутрашње стање (тј. вредност неког поља) може да

###### се промени назива се мутирајући објекат.

######  У супротном се ради о немутирајућем објекту.

######  Стога треба пажљиво радити са конструкторима мутирајућих

###### објеката.

######  Наиме, може се догодити да се, при извршавању конструктора,

###### вредност поља новокреираног објекта постави тако да садржи

###### вредност аргумента конструктора:

```
 У том случају стварни аргумент конструктора и поље новокреираног
објекта постају „везани“ и реферишу на исти објекат.
```
```
 Због тога промена објекта аргумента конструктора доводи до промене
поља новокреираног објекта и обрнуто.
```
### Копирајући конструктор


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 37 / 64
class Line **extends** GeometryObject **{**
Point a **;**
Point b **;**
Line **(** Point a **,** Point b **) {
this.** a **=** a **;
this.** b **=** b **;
}**
public static void main **(** String **[]** argsKL **) {**
Point tackaA **= new** Point **(** 19 **,** 20 **);**
Point tackaB **= new** Point **(** 7 **,** 52 **);**
Line linijaAB **= new** Line **(** tackaA **,** tackaB **);**
tackaA**.** setX **(** 200 **);**
// ovde je doslo do promene vrednosti linijaAB
// sa [(19,20)-(7, 52)] na [(200,20)-(7, 52)]
// iako nije radjeno sa linijaAB, vec sa tackaA
**}
}**

### Копирајући конструктор (2)


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 38 / 64

######  Да би се избегле такве ситуације, потребно је уместо употребе

###### референце на исти објекат направити копију објекта.

###### Пример.

class Line **extends** GeometryObject **{**

Point a **;**

Point b **;**

Line **(** Point a **,** Point b **) {**

**this.** a **= new** Point **(** a**.** x **,** a**.** y **);**

**this.** b **= new** Point **(** b**.** x **,** b**.** y **);**

**}**

**}**

### Копирајући конструктор (3)


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 39 / 64

- Сада више нема „везивања“ поља и аргумента.
- Међутим, запис је рогобатан:
    - нарочито у случају када мутирајући објекат
       који представља поље новог објекта има сложену структуру.
- У прошлом случају било би јако добро када би постојала

###### могућност да се једноставном наредбом направи нова копија.

- Да би се то постигло, потребно је да у класи која описује тип

###### поља постоји тзв. копирајући конструктор.

- Да би се истакло да копирајући конструктор не може да

###### модификује своје аргументе користи се модификатор final.

### Копирајући конструктор (4)


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 40 / 64
class Point **extends** GeometryObject **{**
int x **;** int y **;**
Point **(** int x **,** int y **) {
this.** x **=** x **;
this.** y **=** y **;
}**
Point **(** final Point tacka **) {
this.** x **=** tacka**.** x **;
this.** y **=** tacka**.** y **;
}
}**

### Копирајући конструктор (5)


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 41 / 64
class Line **extends** GeometryObject **{**
Point a **;**
Point b **;**
Line **(** Point a **,** Point b **) {
this.** a **= new** Point **(** a **);
this.** b **= new** Point **(** b **);
}**
public static void main **(** String **[]** argsKL **) {**
Point tackaA **= new** Point **(** 19 **,** 20 **);**
Point tackaB **= new** Point **(** 7 **,** 52 **);**
Line linijaAB **= new** Line **(** tackaA **,** tackaB **);**
tackaA**.** setX **(** 200 **);**
// promena kod tackaA ne menja vrednost linijaAB
**}
}**

### Копирајући конструктор (6)


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 42 / 64

- Процес дефинисања метода у поткласи који има исти потпис као

###### и метод у наткласи назива се превазилажење метода.

- Способност подкласе да превазиђе метод омогућује да нека класа:

###### 1. наследи „довољно блиску“ надкласу

###### 2. и да по потреби модификује њено понашање.

- Нови метод има исто име, исти број и типове параметара и враће

###### резултат истог типа као метод надкласе који се превазилази.

- Нови метод може да врати и подтип типа који враћа метод

###### надкласе, што се назива коваријантни тип резултата.

### Превазилажење метода


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 43 / 64

- Када се превазилази метод пожељно је користи анотацију

@Override.

- На тај начин се даје компајлеру да желимо да урадимо

###### превазилажење и он нас упозорава уколико метод са таквим

###### потписом не постоји у надкласи.

public class Line **{**
void drawLine **(){**
//implementacija crtanja linije u nadklasi
**}
}**

public class DottedLine **extends** Line **{**

@Override
void drawLine **() {**
//prevazilazimo implementaciju iz nadklase
**}
}**

### Превазилажење метода (2)


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 44 / 64

- Позивање одговарајућег метода дефинисаног у наткласи дате

###### класе, а који је превазиђен у поткласи, реализује се коришћењем

###### кључне речи super.

###### Пример.

void mojMetod **(** int x **,** int y **) {**
// nekе naredbe
**super.** mojMetod **(** x **,** y **);**
// jos naredbi
**}**

void mojMetod2 **(** int x **,** int y **) {**
// nekе naredbe
mojMetod **(** x **,** y **);**
// poziva se metod definisan u istoj ovoj klasi
**super.** mojMetod **(** x **,** y **);**
// poziva se metod definisan u nadklasi
// jos naredbi
**}**

### Превазилажење метода ( 3 )


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 45 / 64

- Превазилажење конструктора се не може извршити,

###### јер конструктор има исто име као класа у којој се налази.

- Приликом конструисања примерка поткласе, тј. извршења

###### конструктора поткласе бива позван конструктор наткласе.

- Ако у наткласи није дефинисан конструктор, тада бива позван

###### подразумевани имплицитни конструктор наткласе.

- Експлицитно позивање конструктора наткласе се може

###### реализовати кључном речју super као у случају позива метода.

**super(** arg1 **,** arg2 **,** ... **)**

### Превазилажење метода ( 4 )


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 46 / 64

###### Пример.

```
class LabeledPoint extends Point {
String label ;
LabeledPoint ( int x , int y , String label ) {
super( x , y );
this. label = label ;
}
}
```
### Превазилажење метода ( 5 )


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 47 / 64

######  Јава омогућава креирање рекурзивних метода.

######  Шта је то рекурзија?

######  Рекурзивни методи се извршавају:

1. или тако што метод позива самога себе (тзв. саморекурзија)
2. или тако што се у оквиру једног метода позива неки други, који
    опет позива овај први итд. (тзв. узајамна рекурзија)

######  Који концепти код Јава виртуелне машине омогућавају

###### успешан рад рекурзивних метода у Јави?

######  Навести као илустрацију пример неког метода који је

###### реализован на рекурзивни начин.

### Рекурзивни методи


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 48 / 64

###### Метод финализатор је дефинисан у оквиру класе Object,

###### па свака класа у Јави може да га превазиђе.

- Овај метод се може бити позван при сакупљању отпадака.
- Имплементација овог метода у класи Object не ради ништа.

###### Програмер може одлучити да у методу класе који га превазилази

###### извршава нпр. ослобађање ресурса са којима не управља Јава

###### виртуелна машина.

- Метод се позива са finalize().
- Може се превазићи у сопственој класи са:
protected void finalize **() {**
......
**}**
- Обично није неопходно његово коришћење.

### M етод финализатор


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 49 / 64

- Свака Јава апликација се састоји из одређеног броја класа и

###### обавезног метода main.

- Заглавље метода main има облик:

_име низ аргумената типа_ String

###### public static void main ( String args []) { ... .}

_јавни класни не враћа вредност_

- Јава апликацији се могу проследити аргументи типа String са

###### командне линије

C:> java MojaAplikacija prvi 3 5.34

C:> java Prvi Ovo su argumenti

C:> java Prvi “Ovo su argumenti”

### Апликација и метод main


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 50 / 64

- За креирање примерака (конкретних објекта неке класе)

###### користи се оператор new.

###### Примери:

###### String niska = new String ();

```
Random slicajan = new Random ();
Knjiga x = new Knjiga ();
Point t = new Point ( 20 30 );
```
- Описати аутоматско управљање меморијом за објекте.
- Описати улогу сакупљача отпадака.

### Објекти


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 51 / 64

######  Компоненте објекта су: инстанцне променљиве и методи.

######  Као што је већ истакнуто, компонентама објекта приступа се

###### преко тзв. тачка-нотације.

###### Пример.

###### (а) Приступ променљивим примерка:

prviObjekt**.** prom **;** prviObjekt**.** prom**.** stanje **;**
prviObjekat**.** prom**.** stanje **= true;**

prviObjekat**.** stampajMe **();**

###### (б) Приступ методима:

prviObjekat**.** uzmiIme **();**

prvi objekat**.** postaviVelicinu **(** 20 **);**

prviObjekat**.** prom**.** metod3 **(** arg1 **,** arg2 **,** arg3 **);** // pozvan preko promen.
prviObjekat**.** getClass **().** getName **();** // metod iz metoda

### Објекти (2)


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 52 / 64

######  Када се креира објекат, променљива којој се додељује

###### представља показивач (референцу) на тај објекат.

######  При позиву метода, у случају аргумената који представљају

###### објекте, прослеђује се вредност референце на објекат,

###### а не сам објекат!

######  Обрнуто важи за аргументе метода примитивног типа, ту

###### променљива садржи податак и дупликат текуће вредности

###### променљиве тј. податка се прослеђује методу.

######  Дакле, у оба случаја се врши супституција вредности, само што

###### је код објектних аргумената у питању вредност референце.

###### tacka1 Objekat

###### tacka2

###### x: 20

###### y: 20

### Објекти (3)


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 53 / 64

###### Поређење објеката

- Могуће је примењивати два оператора за поређење:

###### = = !=

- У овом случају, објекти се сматрају једнаким ако заузимају исти

###### простор у меморији.

- Не постоји могућност преоптерећења оператора у програмском

###### језику Јава, па самим тим ни оператора = = и !=.

- Други начин не употребом метода equals који је дефинисан у

###### оквиру класе Object, па свака класа у Јави може да га превазиђе.

- Имплементација овог метода у класи Object проверава да ли су

###### објекти идентички једнаки.

- Програмер може одлучити да у својој класи превазиђе овај метод

###### нпр. тако да враће true нпр. када су садржаји свих поља исти.

### Објекти (4)


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 54 / 64

###### Одређивање класе објекта

- Може се постићи коришћењем метода getClass, који је

###### дефинисан у класи Object и тај метод се не може се превазићи.

- Он враће објекат типа Class, који садржи методе (више од 50)

###### помоћу којих се могу добити информације о датој класи. О

###### томе ће бити више речи у делу који се односи на рефлексију.

###### Пример.

###### String runtimeClassName = objekat. getClass (). getName ();

###### Припадност објекта класи

###### Реализује се помоћу оператора instanceof

###### Пример.

###### “bilo sta” instanceof String // true

Point tacka **= new** Point **(** 10 **,** 10 **);**
tacka **instanceof** String // false

### Објекти (5)


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 55 / 64

######  Када се говори о конверзији типова, може се говорити о:

###### (а) конвертовању примитивних типова у примитивне

###### (imetipa) vrednost

###### Пример.

###### ( int )( x / y );

###### (б) конвертовању објеката у објекте

###### Могуће је само код класа повезаних наслеђивањем и класа и

###### интерфејса повезаних имплементацијом.

###### (imeklase) objekat

###### Пример.

```
Vozilo x ; Vozilo x = new Kamion ();
Kamion y ; Kamion y ;
y = new Kamion (); y = ( Kamion ) x ;
x = y ; // Eksplicitna konverzija nеpotrebna
```
### Конверзија типова


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 56 / 64

###### (в) конвертовању примитивних типова у објекте и обрнуто.

###### У принципу, није могуће, осим код тзв. класа-омотача

###### примитивних типова.

###### У пакету java.lang постоје класе: Integer, Float, Boolean, ...

###### Пример.

```
Integer ceoObj = new Integer ( 45 );
int ceo = ceoObj. intValue ();
Integer ceoObj2 = new Integer ( 2 * ceo );
```
###### Почев од верзије 6, Јава подржава и аутоматску конверзију

###### између података примитивног типа и објеката у

###### одговарајућим класама-омотачима.

### Конверзија типова (2)


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 57 / 64

- Иницијализациони блок је блок који се налази у оквиру

###### дефиниције класе. Разликују се:

###### 1. Иницјализациони блок примерка

###### (инстанцни инцијализациони блок)

###### 2. Иницијализациони блок класе

###### (статички инцијализациони блок)

```
static int staticVariable ;
int nonStaticVariable ;
// Staticki inic. blok se izvrsava jednom po klasi.
static {
System. out. println ( "Static initalization." );
staticVariable = 5 ;
}
// Instanci se poziva pre konstruktora
{
System. out. println ( "Instance initialization." );
nonStaticVariable = 7 ;
}
```
### Иницијализациони блокови


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 58 / 64

- Стринговни тип је објектни тип који се користи за представљање

###### текста, који се чува као низ знакова.

- Примерци класе String не могу да мутирају, тј. да мењају вредност.
- Дакле, када се извршава операција над постојећим стринг

###### објектом, као резултат се увек креира нови примерак класе String.

- Као код других објеката, може се користити литерал null за

###### одбацивање објекта на који тренутно реферише дата String

###### променљива.

###### Пример. Постављање променљиве тако да не указује ни на шта.

```
String nulaString = null;
/* String promenljiva koja ne referiše ni na jedan string */
```
### Стрингови


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 59 / 64

- Дужина стринга одређује се позивом метода length().
- Надовезивање, тј. конкатенација стрингова врши се оператором

###### +. Као резултат се креира нови објекат класе String који садржи

###### новодобијени стринг.

###### Пример. Пример надовезивања стрингова.

```
String date = “13. “ ;
String month = “May” ;
String day = date + month ; // rezultat je “13. May”
```
- За доделу надовезаних стрингова се може користити и оператор

###### +=

###### Пример. Пример коришћења доделе уз надовезивање стрингова.

```
String phrase = “The quick brown fox” ;
phrase += “ jumps over the lazy dog” ;
```
### Стрингови (2)


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 60 / 64

- Метод за превођење у стринг је дефинисан у оквиру класе

###### Object, па свака класа у Јави може да га превазиђе.

- Метод toString() у класи Object враће стринг репрезентацију

###### датог објекта.

- Стринг репрезентација сваког од објеката потпуно зависи

###### од структуре тог објекта и то је разлог због код се метод

###### toString() обично превазилази у новонаправљеним класама.

- Дакле, препоручује се да свака од класа има своју

###### реализацију метода за превођење у стринг.

###### @Override

```
public String toString () {
....
}
```
### Стрингови (3)


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 61 / 64

- Израз string1 == string2 проверава да ли две променљиве типа

#### String реферишу на исти објекат у меморији.

- Дакле, не пореде се садржаји String објеката, већ се пореде

###### референце на стринг објекте.

- За поређење String oбјеката у односу на садржај користи се

###### equals() или equalsIgnoreCase().

- Лексикографско поређење стрингова врши се позивом метода
    compareTo(String),
- Метод враће следећу вредност:
    1. < 0 oбјекат је лексикографски „испред“ тј. „мањи“ од аргумента
    2. = 0 објекат је једнак аргументу
    3. > 0 oбјекат је лексикографски „иза“ тј. „већи“ од аргумента

### Стрингови (4)


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 62 / 64
**Остале методе**

- valueOf()
    Статички метод који креира String објекат од вредности произвољног
    примитивног типа.
- startsWith(String s), endsWith(String)
    Овим методама се провера да ли стринг има прослеђени стринг као
    део садржаја на свом почетку или крају.
- indexOf(int ch), indexOf(String str)
    Овим методама се реализује претраживање датог стринга, слева
    удесно тј. од почетка према крају. Метод враћа (нула-базиран) индекс
    прве појаве датог елемента или - 1 елеменат ниј пронађен.
- lastIndexOf(int ch), lastIndexOf(String str)
    Овим методама се реализује претраживање датог стринга, сдесна
    улево тј. од краја према почетку. Метод враћа (нула-базиран) индекс
    прве појаве датог елемента или -1 елеменат ниј пронађен.

### Стрингови (5)


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 63 / 64
**Остале методе**

- String substring(int)
    Метод враћа подстринг датог стринга који почиње од (нула базираног)
    индекса start задатог као аргумент.
- String substring(int start, int end)
    Метод враћа подстринг датог стринга који почиње од (нула базираног)
    индекса start, a завршава са индексом end- 1
- String replace(char, char)
    Метод сваку појаву првог знакау стрингу замењује другим знаком,
    и као резултат вратити новодобијени стринг.
- String trim()
    Метод брише белине са почетка/краја стринга и као резултат враћа
    новодобијени стринг.
- char[] toCharArray()
    Метод прави низ знакова на основу садржаја датог String објекта
- String.copyValueOf(char[]);
    Статички метод креира String објект на основу низа знакова који су
    прослеђени као аргумент.

### Стрингови (6)


Математички факултет (^) {vladaf, kartelj}@matf.bg.ac.vladaf@matf.bg.ac.rs rs 64 / 64

## Захвалница

##### Велики део материјала који је укључен у ову презентацију је

##### преузет из презентације коју је раније (у време када је он

##### држао курс Објектно орјентисано програмирање) направио

##### проф. др Душан Тошић.

##### Хвала проф. Тошићу што се сагласио са укључивањем тог

##### материјала у садашњу презентацији, као и на помоћи коју ми

##### је пружио током конципцирања и реализације курса.


